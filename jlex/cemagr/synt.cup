package cemagr;
import java_cup.runtime.*;
import java.io.FileInputStream;

parser code {:
	public static void main(String args[]) throws Exception {
        System.setIn(new FileInputStream("cemagr/example.txt"));
		new parser(new Yylex(System.in)).parse();
	}
:}

terminal Yytoken SEMI, PLUS, MINUS, TIMES, DIV, MOD, VAR_NAME, ASS, EQ, NEQ, GT, GE, LT, LE, NUM;
terminal Yytoken AND, OR, NOT, BOOL;
terminal Yytoken RP, LP, RB, LB, COMMA, THEN;

non terminal ParserNode inst_block, inst, ass_inst, if_inst, loop_inst, foop_inst, switch_inst, case_inst_list, case_inst, otherwise_inst, call_inst, decl, func_decl;
terminal Yytoken IF, ELSE, LOOP, FOOP, FUNC, FUNC_ID, RETURN, STRING, SWITCH, CASE, OTHERWISE;
non terminal ParserNode E0, OP0, E1, OP1, E2, OP2, E3, OP3, E4, OP4, ECONST;
non terminal ParserNode VAR, ARRAY, ARRAY_LIST, STATIC_ARRAY_LIST, STATIC_ARRAY, ARG, ARG_LIST, VAR_LIST;
terminal Yytoken TYPE;

precedence left PLUS, MINUS, OR;
precedence left TIMES, DIV, MOD, AND;
precedence left NOT;

inst_block ::= inst_block inst:exp {: System.out.println(exp); :} | inst:exp {: System.out.println(exp); :};
inst ::= ass_inst:ass {: RESULT = ass; :}
       | if_inst:node {: RESULT = node; :}
       | loop_inst:node {: RESULT = node; :}
       | foop_inst:node {: RESULT = node; :}
       | switch_inst:node {: RESULT = node; :}
       | decl:node {: RESULT = node; :}
       | func_decl:node {: RESULT = node; :};
ass_inst ::= VAR:var ASS E0:exp SEMI {: RESULT = new AssNode((VarReferenceNode) var, exp); :};
E0 ::= E1:exp1 OP0:op E1:exp2 {: RESULT = new BinaryExpression(exp1, (OperatorNode) op, exp2); :}
     | E1:exp {: RESULT = exp; :}
     | STRING:string {: RESULT = new StringNode(string); :} ;
OP0 ::= EQ:op {: RESULT = new OperatorNode(op); :}
      | NEQ:op {: RESULT = new OperatorNode(op); :}
      | GT:op {: RESULT = new OperatorNode(op); :}
      | GE:op {: RESULT = new OperatorNode(op); :}
      | LT:op {: RESULT = new OperatorNode(op); :}
      | LE:op {: RESULT = new OperatorNode(op); :} ;
E1 ::= E1:exp1 OP1:op E2:exp2 {: RESULT = new BinaryExpression(exp1, (OperatorNode) op, exp2); :}
     | E2:exp {: RESULT = exp; :} ;
OP1 ::= PLUS:op {: RESULT = new OperatorNode(op); :}
      | MINUS:op {: RESULT = new OperatorNode(op); :}
      | OR:op {: RESULT = new OperatorNode(op); :} ;
E2 ::= E2:exp1 OP2:op E3:exp2 {: RESULT = new BinaryExpression(exp1, (OperatorNode) op, exp2); :}
     | E3:exp {: RESULT = exp; :} ;
OP2 ::= TIMES:op {: RESULT = new OperatorNode(op); :}
      | DIV:op {: RESULT = new OperatorNode(op); :}
      | MOD:op {: RESULT = new OperatorNode(op); :}
      | AND:op {: RESULT = new OperatorNode(op); :} ;
E3 ::= OP3:op E3:exp {: RESULT = new UnaryExpression((OperatorNode) op, exp); :}
     | E4:exp {: RESULT = exp; :} ;
OP3 ::= NOT:op {: RESULT = new OperatorNode(op); :}
      | MINUS:op {: RESULT = new OperatorNode(op); :};
E4 ::= VAR:var {: RESULT = var; :}
     | NUM:num {: RESULT = new NumNode(num); :}
     | BOOL:bool {: RESULT = new BoolNode(bool); :}
     | LP E0:exp RP {: RESULT = exp; :}
     | call_inst {: RESULT = null; :} ;
ECONST ::= NUM:num {: RESULT = new NumNode(num); :}
         | BOOL:bool {: RESULT = new BoolNode(bool); :}
         | STRING:string {: RESULT = new StringNode(string); :} ;

VAR ::= VAR_NAME:id {: RESULT = new VarReferenceNode(id); :}
      | VAR_NAME:id ARRAY_LIST:arr {: RESULT = new VarReferenceNode(id, (ArrayNode) arr); :} ;
VAR_LIST ::= VAR_LIST COMMA VAR | VAR ;
ARRAY_LIST ::= ARRAY_LIST:next ARRAY:exp {: RESULT = new ArrayNode(exp, (ArrayNode) next); :}
             | ARRAY:exp {: RESULT = new ArrayNode(exp); :} ;
ARRAY ::= LP E1:exp RP {: RESULT = exp; :};
ARG_LIST ::= ARG_LIST COMMA ARG | ARG ;
ARG ::= TYPE VAR_NAME STATIC_ARRAY_LIST {: System.out.println("ARG_DECL_ARRAY"); :}
      | TYPE VAR_NAME {: System.out.println("ARG_DECL"); :} ;

STATIC_ARRAY_LIST ::= STATIC_ARRAY_LIST:next STATIC_ARRAY:exp {: RESULT = new StaticArrayNode(exp, (StaticArrayNode) next); :}
                    | STATIC_ARRAY:exp {: RESULT = new StaticArrayNode(exp); :} ;
STATIC_ARRAY ::= LP NUM:num RP {: RESULT = new NumNode(num); :};


if_inst ::= IF LP E0 RP LB inst_block RB {: System.out.println("IF"); :}
            | IF LP E0 RP LB inst_block RB ELSE LB inst_block RB {: System.out.println("IFELSE"); :} ;

loop_inst ::= LOOP LP E0:cond RP LB inst_block:block RB {: RESULT = new LoopNode(cond, block); :} ;

foop_inst ::= FOOP LP inst_block:p1 E0:cond SEMI inst_block:p2 RP LB inst_block:block RB {: RESULT = new FoopNode(p1, cond, p2, block); :}  ;

switch_inst ::= SWITCH LP E0 RP LB case_inst_list otherwise_inst RB {: System.out.println("SWITCH"); :} ;

case_inst_list ::= case_inst_list case_inst | case_inst ;

case_inst ::= CASE ECONST THEN inst_block {: System.out.println("CASEX"); :} ;

otherwise_inst ::= OTHERWISE THEN inst_block {: System.out.println("OTHERWISE"); :} ;

call_inst ::= FUNC_ID LP VAR_LIST RP |
              FUNC_ID LP RP ;

func_decl ::= FUNC TYPE FUNC_ID LP ARG_LIST RP LB inst_block RETURN E0 SEMI RB {: System.out.println("FUNC"); :}
              | FUNC TYPE FUNC_ID LP RP LB inst_block RETURN E0 SEMI RB {: System.out.println("FUNC"); :} ;

decl ::= TYPE:type VAR_NAME:var STATIC_ARRAY_LIST:arr SEMI {: RESULT = new DeclarationNode(new TypeNode(type), new VarIDNode(var), (StaticArrayNode) arr); :}
       | TYPE:type VAR_NAME:var SEMI {: RESULT = new DeclarationNode(new TypeNode(type), new VarIDNode(var)); :} ;
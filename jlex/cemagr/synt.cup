package cemagr;
import java_cup.runtime.*;
import java.io.FileInputStream;

parser code {:
	public static void main(String args[]) throws Exception {
        System.setIn(new FileInputStream("cemagr/example.txt"));
		new parser(new Yylex(System.in)).parse();
	}
:}

terminal Yytoken SEMI, PLUS, MINUS, TIMES, DIV, MOD, VAR_NAME, ASS, EQ, NEQ, GT, GE, LT, LE, NUM;
terminal Yytoken AND, OR, NOT, BOOL;
terminal Yytoken RP, LP, RB, LB, COMMA, THEN;

non terminal ParserNode inst_block, inst, ass_inst, if_inst, loop_inst, foop_inst, switch_inst, case_inst_list, case_inst, otherwise_inst, call_inst, decl, func_decl;
terminal Yytoken IF, ELSE, LOOP, FOOP, FUNC, FUNC_ID, RETURN, STRING, SWITCH, CASE, OTHERWISE;
non terminal ParserNode E0, OP0, E1, OP1, E2, OP2, E3, OP3, E4, OP4, ECONST;
non terminal ParserNode VAR, ARRAY, ARRAY_LIST, STATIC_ARRAY_LIST, STATIC_ARRAY, ARG, ARG_LIST, VAR_LIST;
terminal Yytoken TYPE;

precedence left PLUS, MINUS, OR;
precedence left TIMES, DIV, MOD, AND;
precedence left NOT;

inst_block ::= inst_block inst | inst;
inst ::= ass_inst | if_inst | loop_inst | foop_inst | switch_inst | decl | func_decl;
ass_inst ::= VAR ASS E0 SEMI {: System.out.println("ASS"); :};
E0 ::= E1:exp1 OP0:op E1:exp2 {: RESULT = new BinaryExpression(exp1, (OperatorNode) op, exp2); :}
     | E1:exp {: RESULT = exp; :}
     | STRING:string {: RESULT = new StringNode(string); :} ;
OP0 ::= EQ:op {: RESULT = new OperatorNode(op); :}
      | NEQ:op {: RESULT = new OperatorNode(op); :}
      | GT:op {: RESULT = new OperatorNode(op); :}
      | GE:op {: RESULT = new OperatorNode(op); :}
      | LT:op {: RESULT = new OperatorNode(op); :}
      | LE:op {: RESULT = new OperatorNode(op); :} ;
E1 ::= E1:exp1 OP1:op E2:exp2 {: RESULT = new BinaryExpression(exp1, (OperatorNode) op, exp2); :}
     | E2:exp {: RESULT = exp; :} ;
OP1 ::= PLUS:op {: RESULT = new OperatorNode(op); :}
      | MINUS:op {: RESULT = new OperatorNode(op); :}
      | OR:op {: RESULT = new OperatorNode(op); :} ;
E2 ::= E2:exp1 OP2:op E3:exp2 {: RESULT = new BinaryExpression(exp1, (OperatorNode) op, exp2); :}
     | E3:exp {: RESULT = exp; :} ;
OP2 ::= TIMES:op {: RESULT = new OperatorNode(op); :}
      | DIV:op {: RESULT = new OperatorNode(op); :}
      | MOD:op {: RESULT = new OperatorNode(op); :}
      | AND:op {: RESULT = new OperatorNode(op); :} ;
E3 ::= OP3:op E3:exp {: RESULT = new UnaryExpression((OperatorNode) op, exp); :}
     | E4:exp {: RESULT = exp; :} ;
OP3 ::= NOT:op {: RESULT = new OperatorNode(op); :}
      | MINUS:op {: RESULT = new OperatorNode(op); :};
E4 ::= VAR {: RESULT = null; :}
     | NUM:num {: RESULT = new NumNode(num); :}
     | BOOL:bool {: RESULT = new BoolNode(bool); :}
     | LP E0:exp RP {: RESULT = exp; :}
     | call_inst {: RESULT = null; :} ;
ECONST ::= NUM:num {: RESULT = new NumNode(num); :}
         | BOOL:bool {: RESULT = new BoolNode(bool); :}
         | STRING:string {: RESULT = new StringNode(string); :} ;

VAR ::= VAR_NAME | VAR_NAME ARRAY_LIST ;
VAR_LIST ::= VAR_LIST COMMA VAR | VAR ;
ARRAY_LIST ::= ARRAY_LIST ARRAY | ARRAY ;
ARRAY ::= LP E1 RP {: System.out.println("IDX"); :};
ARG_LIST ::= ARG_LIST COMMA ARG | ARG ;
ARG ::= TYPE VAR_NAME STATIC_ARRAY_LIST {: System.out.println("ARG_DECL_ARRAY"); :}
      | TYPE VAR_NAME {: System.out.println("ARG_DECL"); :} ;
STATIC_ARRAY_LIST ::= STATIC_ARRAY_LIST STATIC_ARRAY | STATIC_ARRAY ;
STATIC_ARRAY ::= LP NUM:num RP {: System.out.println("IDX_S"); :};


if_inst ::= IF LP E0 RP LB inst_block RB {: System.out.println("IF"); :}
            | IF LP E0 RP LB inst_block RB ELSE LB inst_block RB {: System.out.println("IFELSE"); :} ;

loop_inst ::= LOOP LP E0 RP LB inst_block RB {: System.out.println("LOOP"); :} ;

foop_inst ::= FOOP LP inst_block E0 SEMI inst_block RP LB inst_block RB {: System.out.println("FOOP"); :}  ;

switch_inst ::= SWITCH LP E0 RP LB case_inst_list otherwise_inst RB {: System.out.println("SWITCH"); :} ;

case_inst_list ::= case_inst_list case_inst | case_inst ;

case_inst ::= CASE ECONST THEN inst_block {: System.out.println("CASEX"); :} ;

otherwise_inst ::= OTHERWISE THEN inst_block {: System.out.println("OTHERWISE"); :} ;

call_inst ::= FUNC_ID LP VAR_LIST RP |
              FUNC_ID LP RP ;

func_decl ::= FUNC TYPE FUNC_ID LP ARG_LIST RP LB inst_block RETURN E0 SEMI RB {: System.out.println("FUNC"); :}
              | FUNC TYPE FUNC_ID LP RP LB inst_block RETURN E0 SEMI RB {: System.out.println("FUNC"); :} ;
decl ::= TYPE VAR_NAME STATIC_ARRAY_LIST SEMI {: System.out.println("DECL_ARRAY"); :}
       | TYPE VAR_NAME SEMI {: System.out.println("DECL"); :} ;